import { ChatCompletionSystemMessageParam, ChatCompletionUserMessageParam } from 'openai/resources/index.mjs';
import { DefaultAzureCredential, getBearerTokenProvider } from "@azure/identity";
import { AzureOpenAI } from "openai";
import "dotenv/config";


interface GeneratedContent {
  mainContent: string;
  hashtags: string[];
  insights: string[];
}

interface ToneGuidelines {
  [key: string]: string[];
}

export class AzureOpenAIService {
  private client: AzureOpenAI;
  private readonly toneGuidelines: ToneGuidelines;

  constructor() {

    if (!process.env.AZURE_OPENAI_ENDPOINT) {
      throw new Error("AZURE_OPENAI_ENDPOINT must be configured in environment variables");
    }

    const scope = 'https://cognitiveservices.azure.com/.default';
    const credential = new DefaultAzureCredential();
    const azureADTokenProvider = getBearerTokenProvider(credential, scope);

    const deployment = process.env.AZURE_OPENAI_DEPLOYMENT_NAME || 'gpt-4o';
    const apiVersion = "2024-05-13";

    this.client = new AzureOpenAI({
      azureADTokenProvider,
      deployment,
      apiVersion,
      endpoint: process.env.AZURE_OPENAI_ENDPOINT,
    });

    this.toneGuidelines = {
      technical: [
        'Use precise technical language',
        'Include specific data points and statistics',
        'Maintain professional credibility',
        'Focus on accuracy and clarity',
        'Use industry-standard terminology'
      ],
      casual: [
        'Use conversational, friendly language',
        'Include relatable examples',
        'Keep the tone light and engaging',
        'Write as if talking to a friend',
        'Use everyday language and expressions'
      ],
      motivational: [
        'Use inspiring and empowering language',
        'Focus on positive outcomes and possibilities',
        'Include clear calls-to-action',
        'Create emotional connections',
        'Emphasize growth and achievement'
      ]
    };
  }

  /**
   * Generates content for the microblog based on the parameters provided
   * @param topic - The main topic of the microblog
   * @param tone - The desired tone of voice (technical, casual, motivational) 
   * @param keywords - Optional keywords to include in the content
   */
  async generateMicroblogContent(topic: string, tone: string, keywords?: string): Promise<GeneratedContent> {
    return this.retry(async () => {
      try {
        // Definimos explicitamente os tipos das mensagens
        const systemMessage: ChatCompletionSystemMessageParam = {
          role: "system",
          content: this.createSystemPrompt()
        };

        const userMessage: ChatCompletionUserMessageParam = {
          role: "user",
          content: this.createUserPrompt(topic, tone, keywords)
        };

        const result = await this.client.chat.completions.create({
          messages: [systemMessage, userMessage],
          model: "",  // O modelo Ã© especificado no deployment
          temperature: 0.7,
          max_tokens: 500,
          response_format: { type: "json_object" }
        });

        const content = result.choices[0]?.message?.content;
        if (!content) {
          throw new Error("No content was generated by the AI");
        }

        const parsedContent = JSON.parse(content) as GeneratedContent;
        if (!this.validateResponse(parsedContent)) {
          throw new Error("Generated content does not meet the required format");
        }

        return parsedContent;
      } catch (error) {
        console.error("Error in content generation:", error);
        throw error;
      }
    });
  }

  private createSystemPrompt(): string {
    return `You are a professional content creator specializing in creating engaging microblog posts.
              Your expertise includes:
              - Creating viral-worthy content under 280 characters
              - Understanding social media engagement patterns
              - Crafting content that drives discussion and shares
              - Adapting tone while maintaining authenticity
              - Selecting impactful and trending hashtags

            Always ensure your responses are:
              1. Concise and impactful
              2. Optimized for social sharing
              3. Properly formatted as JSON
              4. Relevant to the target audience
              5. Engaging and shareable  
    `;
  }

  private createUserPrompt(topic: string, tone: string, keywords?: string): string {
    let prompt = `Create a microblog post about "${topic}"`;

    if (keywords) {
      prompt += ` incorporating these keywords: ${keywords}`;
    }

    const guidelines = this.toneGuidelines[tone] || [];
    prompt += `\n\nTone Requirements (${tone}):\n${guidelines.map(g => `- ${g}`).join('\n')}`;

    prompt += `\n\nFormat your response as JSON:

    {
      "mainContent": "your microblog post (max 280 chars)",
      "hashtags": ["relevant", "hashtags"],
      "insights": ["key insights about the topic"]
    }`;

    return prompt;
  }

  private validateResponse(content: GeneratedContent): boolean {
    const { mainContent, hashtags, insights } = content;

    if (!mainContent || typeof mainContent !== 'string') return false;
    if (mainContent.length > 280) return false;

    if (!Array.isArray(hashtags) || hashtags.length === 0) return false;
    if (!hashtags.every(tag => typeof tag === 'string')) return false;

    if (!Array.isArray(insights) || insights.length === 0) return false;
    if (!insights.every(insight => typeof insight === 'string')) return false;

    return true;
  }

  private async retry<T>(operation: () => Promise<T>, maxAttempts: number = 3, delayMs: number = 1000): Promise<T> {
    let lastError: Error | undefined;

    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        console.warn(`Attempt ${attempt} failed. ${maxAttempts - attempt} attempts remaining.`);

        if (attempt < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, delayMs * attempt));
        }
      }
    }

    throw lastError;
  }
}

export const azureOpenAIService = new AzureOpenAIService();